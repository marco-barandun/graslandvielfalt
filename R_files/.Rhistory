# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file
species_data$species_features <- lapply(species_data$audio_file, extract_audio_features)
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono
mono_audio <- force.monophonic(audio)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(mfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono
mono_audio <- force.monophonic(audio)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(mfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file
species_data$species_features <- lapply(species_data$audio_file, extract_audio_features)
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono
mono_audio <- channels(audio, stereo = FALSE)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(mfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file
species_data$species_features <- lapply(species_data$audio_file, extract_audio_features)
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- audio::readWave(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono by averaging left and right channels
mono_audio <- audio@left * 0.5 + audio@right * 0.5
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(mfcc(mono_audio, fm = 256, fmax = 8000, lifterexp = 0))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file
species_data$species_features <- lapply(species_data$audio_file, extract_audio_features)
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- seewave::readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono by averaging left and right channels
mono_audio <- seewave::mono(audio)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(seewave::melfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file
species_data$species_features <- lapply(species_data$audio_file, extract_audio_features)
library(audio)
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- audio::readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono by averaging left and right channels
mono_audio <- seewave::mono(audio)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(seewave::melfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file
species_data$species_features <- lapply(species_data$audio_file, extract_audio_features)
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono by averaging left and right channels
mono_audio <- seewave::mono(audio)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(seewave::melfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file
species_data$species_features <- lapply(species_data$audio_file, extract_audio_features)
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono by averaging left and right channels
mono_audio <- mono(audio)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(seewave::melfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file
species_data$species_features <- lapply(species_data$audio_file, extract_audio_features)
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono by averaging left and right channels
mono_audio <- mono(audio)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(melfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file
species_data$species_features <- lapply(species_data$audio_file, extract_audio_features)
# Combine the extracted features from the list into a data frame
species_data$species_features <- do.call(rbind, lapply(species_data$species_features, as.data.frame))
species_data$species_features <- lapply(species_data$species_features, function(x) {
n_missing_cols <- max_cols - ncol(x)
if (n_missing_cols > 0) {
x <- cbind(x, matrix(NA, nrow = nrow(x), ncol = n_missing_cols))
}
return(x)
})
# Pad feature matrices with NA values to make them consistent for binding
max_cols <- max(sapply(species_data$species_features, ncol))
species_data$species_features <- lapply(species_data$species_features, function(x) {
n_missing_cols <- max_cols - ncol(x)
if (n_missing_cols > 0) {
x <- cbind(x, matrix(NA, nrow = nrow(x), ncol = n_missing_cols))
}
return(x)
})
# Combine the extracted features from the list into a single data frame
species_data$species_features <- do.call(rbind, lapply(species_data$species_features, as.data.frame))
# Determine the maximum number of columns for all feature matrices
max_cols <- max(sapply(species_data$species_features, ncol))
# Function to pad or truncate a matrix to have a specified number of columns
pad_or_truncate_matrix <- function(matrix, num_cols) {
if (ncol(matrix) < num_cols) {
# Pad with zeros
return(cbind(matrix, matrix(0, nrow = nrow(matrix), ncol = num_cols - ncol(matrix))))
} else if (ncol(matrix) > num_cols) {
# Truncate
return(matrix[, 1:num_cols])
} else {
return(matrix)
}
}
# Make all feature matrices have the same number of columns
species_data$species_features <- lapply(species_data$species_features, pad_or_truncate_matrix, num_cols = max_cols)
# Combine the extracted features from the list into a single data frame
species_data$species_features <- do.call(rbind, lapply(species_data$species_features, as.data.frame))
# Determine the maximum number of columns for all feature matrices
max_cols <- max(sapply(species_data$species_features, ncol))
# Function to pad or truncate a matrix to have a specified number of columns
pad_or_truncate_matrix <- function(matrix, num_cols) {
if (ncol(matrix) < num_cols) {
# Pad with zeros
return(cbind(matrix, matrix(0, nrow = nrow(matrix), ncol = num_cols - ncol(matrix))))
} else if (ncol(matrix) > num_cols) {
# Truncate
return(matrix[, 1:num_cols])
} else {
return(matrix)
}
}
# Make all feature matrices have the same number of columns
species_data$species_features <- lapply(species_data$species_features, pad_or_truncate_matrix, num_cols = max_cols)
# Combine the extracted features from the list into a single data frame using dplyr's bind_rows
species_data$species_features <- dplyr::bind_rows(lapply(species_data$species_features, as.data.frame))
# Make all feature matrices have the same number of columns
species_data$species_features <- lapply(species_data$species_features, pad_or_truncate_matrix, num_cols = max_cols)
# Convert the list of feature matrices to a single data frame
species_data$species_features <- species_data$species_features %>%
bind_rows(.id = "species")
library(tidyverse)
# Convert the list of feature matrices to a single data frame
species_data$species_features <- species_data$species_features %>%
bind_rows(.id = "species")
# Make all feature matrices have the same number of columns
species_data$species_features <- lapply(species_data$species_features, pad_or_truncate_matrix, num_cols = max_cols)
# Convert the list of feature matrices to a list of data frames with the same columns
species_data$species_features <- lapply(species_data$species_features, as.data.frame)
# Combine the list of data frames into a single data frame
species_data$species_features <- do.call(rbind, species_data$species_features)
# Make all feature matrices have the same number of columns
species_data$species_features <- lapply(species_data$species_features, pad_or_truncate_matrix, num_cols = max_cols)
# Convert the list of feature matrices to a list of data frames with the same columns
species_data$species_features <- lapply(species_data$species_features, as.data.frame)
# Combine the list of data frames into a single data frame with .id = "species"
species_data$species_features <- dplyr::bind_rows(species_data$species_features, .id = "species")
# Apply feature extraction for each audio file and add species label
species_data$species_features <- Map(function(features, species) {
features <- extract_audio_features(features)
features$species <- species
return(features)
}, species_data$audio_file, species_data$species)
# Combine the list of data frames into a single data frame
species_data$species_features <- do.call(rbind, species_data$species_features)
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono by averaging left and right channels
mono_audio <- mono(audio)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(melfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Step 3: Feature Engineering and Data Augmentation
# Extract features (e.g., MFCCs) from the mp3 audio files for each species and create a data frame
extract_audio_features <- function(audio_file) {
audio <- readMP3(audio_file)
# Preprocess audio (e.g., resampling, normalization, etc.)
# Convert stereo audio to mono by averaging left and right channels
mono_audio <- mono(audio)
# Extract Mel-frequency cepstral coefficients (MFCCs) using seewave package
mfcc_features <- as.data.frame(melfcc(mono_audio))
# Return the extracted features as a data frame
return(mfcc_features)
}
# Apply feature extraction for each audio file and add species label
species_data$species_features <- Map(function(features, species) {
features <- extract_audio_features(features)
# Determine the maximum number of columns for all feature matrices
max_cols <- max(sapply(species_data$species_features, ncol))
# Function to pad or truncate a matrix to have a specified number of columns
pad_or_truncate_matrix <- function(matrix, num_cols) {
if (ncol(matrix) < num_cols) {
# Pad with zeros
return(cbind(matrix, matrix(0, nrow = nrow(matrix), ncol = num_cols - ncol(matrix))))
} else if (ncol(matrix) > num_cols) {
# Truncate
return(matrix[, 1:num_cols])
} else {
return(matrix)
}
}
# Make the feature matrix have the same number of columns
features <- pad_or_truncate_matrix(features, max_cols)
# Add species label to the data frame
features$species <- species
return(features)
}, species_data$audio_file, species_data$species)
# Combine the list of data frames into a single data frame
species_data$species_features <- do.call(rbind, species_data$species_features)
# Apply feature extraction for each audio file and add species label
species_data$species_features <- Map(function(features, species) {
features <- extract_audio_features(features)
# Determine the maximum number of columns for all feature matrices
max_cols <- max(sapply(species_data$species_features, ncol))
# Function to pad or truncate a matrix to have a specified number of columns
pad_or_truncate_matrix <- function(matrix, num_cols) {
if (ncol(matrix) < num_cols) {
# Pad with zeros
return(cbind(matrix, matrix(0, nrow = nrow(matrix), ncol = num_cols - ncol(matrix))))
} else if (ncol(matrix) > num_cols) {
# Truncate
return(matrix[, 1:num_cols])
} else {
return(matrix)
}
}
# Make the feature matrix have the same number of columns
features <- pad_or_truncate_matrix(features, max_cols)
# Add species label to the data frame
features$species <- species
return(features)
}, species_data$audio_file, species_data$species)
# Convert the list of data frames into a tibble and combine them using bind_rows
species_data$species_features <- dplyr::bind_rows(species_data$species_features)
# Apply feature extraction for each audio file and add species label
species_data$species_features <- Map(function(features, species) {
features <- extract_audio_features(features)
# Determine the maximum number of columns for all feature matrices
max_cols <- max(sapply(species_data$species_features, ncol))
# Function to pad or truncate a matrix to have a specified number of columns
pad_or_truncate_matrix <- function(matrix, num_cols) {
if (ncol(matrix) < num_cols) {
# Pad with zeros
return(cbind(matrix, matrix(0, nrow = nrow(matrix), ncol = num_cols - ncol(matrix))))
} else if (ncol(matrix) > num_cols) {
# Truncate
return(matrix[, 1:num_cols])
} else {
return(matrix)
}
}
# Make the feature matrix have the same number of columns
features <- pad_or_truncate_matrix(features, max_cols)
# Add species label to the data frame
features$species <- species
return(features)
}, species_data$audio_file, species_data$species)
# Combine the list of data frames into a single data frame using rbindlist
species_data$species_features <- data.table::rbindlist(species_data$species_features)
# Apply feature extraction for each audio file and add species label
species_data$species_features <- Map(function(features, species) {
features <- extract_audio_features(features)
# Determine the maximum number of columns for all feature matrices
max_cols <- max(sapply(species_data$species_features, ncol))
# Function to pad or truncate a matrix to have a specified number of columns
pad_or_truncate_matrix <- function(matrix, num_cols) {
if (ncol(matrix) < num_cols) {
# Pad with zeros
return(cbind(matrix, matrix(0, nrow = nrow(matrix), ncol = num_cols - ncol(matrix))))
} else if (ncol(matrix) > num_cols) {
# Truncate
return(matrix[, 1:num_cols])
} else {
return(matrix)
}
}
# Make the feature matrix have the same number of columns
features <- pad_or_truncate_matrix(features, max_cols)
# Add species label to the data frame
features$species <- species
return(features)
}, species_data$audio_file, species_data$species)
# Combine the list of data frames into a single data frame using rbindlist
species_data$species_features <- data.table::rbindlist(species_data$species_features)
library(tidyverse)
library(stringr)
library(sf)
library(mapview)
library(sp)
library(rgdal)
library(data.table)
library(DT)
setwd("/Users/marco/GitHub/graslandvielfalt/R_files/")
source("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/3_scripts/config_1_readVegedaz_marco.R")
plots <- read_csv("/Users/marco/GitHub/graslandvielfalt/R_files/2023-joinedPlotSelection_v3.csv") %>%
filter(!priority %in% c("MP5", "MP6", "MP7"))
dorothea_orth <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")
hohl_orth <- read_csv("/Users/marco/GitHub/graslandvielfalt/R_files/hohl_grashopperAbundance.csv")
p <- dorothea_orth$samp
View(p)
p <- p %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("1.", "". rn))
p <- p %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("1.", "", rn))
View(p)
p <- p %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub(".1", "", rn))
p <- dorothea_orth <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub(".1", "", rn))
p <-readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub(".1", "", rn))
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn")
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub(".1", "", rn))
View(p)
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn")
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn))
View(p)
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn)) %>%
mutate(Datum = as.Date(Datum, format = "%Y-%m-%d")) %>%  # Convert 'Datum' to Date type
group_by(rn) %>%
summarize(date_diff = max(Datum) - min(Datum))
# Create a histogram
ggplot(p_diff, aes(x = date_diff)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
labs(x = "Date Difference (days)", y = "Frequency", title = "Distribution of Date Differences")
# Create a histogram
ggplot(p, aes(x = date_diff)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
labs(x = "Date Difference (days)", y = "Frequency", title = "Distribution of Date Differences")
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn)) %>%
mutate(Datum = as.Date(Datum, format = "%Y-%m-%d")) %>%  # Convert 'Datum' to Date type
group_by(rn) %>%
summarize(date_diff = max(Datum) - min(Datum)) %>%
filter(!is.na(date_diff) & is.finite(date_diff))  # Filter out missing or non-finite values
# Create a histogram
ggplot(p, aes(x = as.numeric(date_diff))) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
labs(x = "Date Difference (days)", y = "Frequency", title = "Distribution of Date Differences")
View(p)
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn)) %>%
mutate(Datum = as.Date(Datum, format = "%Y-%m-%d"))
View(p)
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn)) %>%
group_by(rn) %>%
summarize(date_diff = as.numeric(max(as.Date(Datum, format = "%Y-%m-%d")) - min(as.Date(Datum, format = "%Y-%m-%d")))) %>%
filter(!is.na(date_diff) & is.finite(date_diff))  # Filter out missing or non-finite values
View(p)
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn))
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn)) %>%
group_by(rn)
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn)) %>%
group_by(rn) %>%
summarize(date_diff = as.numeric(max(as.Date(Datum, format = "%Y-%m-%d")) - min(as.Date(Datum, format = "%Y-%m-%d"))))
View(p)
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn)) %>%
group_by(rn) %>%
summarize(max_date = max(as.Date(Datum, format = "%Y-%m-%d")),
min_date = min(as.Date(Datum, format = "%Y-%m-%d"))) %>%
mutate(date_diff = as.numeric(max_date - min_date)) %>%
filter(!is.na(date_diff) & is.finite(date_diff))  # Filter out missing or non-finite values
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn))
str(p)
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn),
Datum = as.Date(Datum, format = "%d.%m.%Y"))  # Convert 'Datum' to Date type
# Group by 'rn' and calculate date difference
p_diff <- p %>%
group_by(rn) %>%
summarize(date_diff = as.numeric(max(Datum) - min(Datum))) %>%
filter(!is.na(date_diff) & is.finite(date_diff))  # Filter out missing or non-finite values
# Create a histogram
ggplot(p_diff, aes(x = date_diff)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
scale_x_continuous(labels = scales::comma_format()) +  # Format x-axis labels
labs(x = "Date Difference (days)", y = "Frequency", title = "Distribution of Date Differences")
# Group by 'rn' and calculate date difference
p_diff <- p %>%
group_by(rn) %>%
summarize(date_diff = as.numeric(max(Datum) - min(Datum))) %>%
filter(!is.na(date_diff) & is.finite(date_diff) | date_diff == 0)  # Filter out missing or non-finite values
# Create a histogram
ggplot(p_diff, aes(x = date_diff)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
scale_x_continuous(labels = scales::comma_format()) +  # Format x-axis labels
labs(x = "Date Difference (days)", y = "Frequency", title = "Distribution of Date Differences")
# Group by 'rn' and calculate date difference
p_diff <- p %>%
group_by(rn) %>%
summarize(date_diff = as.numeric(max(Datum) - min(Datum))) %>%
filter(!is.na(date_diff) & is.finite(date_diff) | date_diff = 0)  # Filter out missing or non-finite values
# Create a histogram
ggplot(p_diff, aes(x = date_diff)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
scale_x_continuous(labels = scales::comma_format()) +  # Format x-axis labels
labs(x = "Date Difference (days)", y = "Frequency", title = "Distribution of Date Differences")
# Group by 'rn' and calculate date difference
p_diff <- p %>%
group_by(rn) %>%
summarize(date_diff = as.numeric(max(Datum) - min(Datum))) %>%
filter(!is.na(date_diff) & is.finite(date_diff) & date_diff > 2)  # Filter out missing or non-finite values
# Create a histogram
ggplot(p_diff, aes(x = date_diff)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
scale_x_continuous(labels = scales::comma_format()) +  # Format x-axis labels
labs(x = "Date Difference (days)", y = "Frequency", title = "Distribution of Date Differences")
View(p)
plots <- read_csv("/Users/marco/GitHub/graslandvielfalt/R_files/2023-joinedPlotSelection_v3.csv") %>%
filter(!priority %in% c("MP5", "MP6", "MP7"))
filter(rn %in% plots$plotID)
plots <- read_csv("/Users/marco/GitHub/graslandvielfalt/R_files/2023-joinedPlotSelection_v3.csv") %>%
filter(!priority %in% c("MP5", "MP6", "MP7"))
p <- readVegedaz("/Users/marco/GitHub/GitHub_G4B/2023_re-survey/1_original_data/Data_Dorothea_Kampmann/NFP48_C_Heuschreckenaufnahmen.tab")$samp %>%
rownames_to_column(var = "rn") %>%
mutate(rn = gsub("\\.1", "", rn),
Datum = as.Date(Datum, format = "%d.%m.%Y")) %>%   # Convert 'Datum' to Date type %>%
filter(rn %in% plots$plotID)
# Group by 'rn' and calculate date difference
p_diff <- p %>%
group_by(rn) %>%
summarize(date_diff = as.numeric(max(Datum) - min(Datum))) %>%
filter(!is.na(date_diff) & is.finite(date_diff) & date_diff > 2)  # Filter out missing or non-finite values
# Create a histogram
ggplot(p_diff, aes(x = date_diff)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
scale_x_continuous(labels = scales::comma_format()) +  # Format x-axis labels
labs(x = "Date Difference (days)", y = "Frequency", title = "Distribution of Date Differences")
View(p)

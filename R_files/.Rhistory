# Locality data thinning using spThin package thin.par is distance in km
presences_thinned <- spThin::thin(sp.occ, lat.col = "coords.x1", long.col = "coords.x2", spec.col = "Species",
thin.par = 5, reps = 5, locs.thinned.list.return = TRUE, write.files = TRUE,
max.files = 5, out.dir = paste("./../tmp/res_thinned_presences/", species, "_thinned_data", sep = ""),
out.base = "thinned_data", write.log.file = TRUE, log.file = "spatial_thin_log.txt",
verbose = TRUE)
sp.occs.thinned <- as.data.frame(presences_thinned[[1]]) %>%
rename(latitude = Latitude) %>%
rename(longitude = Longitude) %>%
mutate(Species = species) %>%
distinct(.keep_all = TRUE) %>%
dplyr::left_join(., Points, by = c("Species", "latitude", "longitude")) %>%
dplyr::select(Species, longitude, latitude, occID, country, source, accepted_name, family)
occs_xy <- sp.occs.thinned[c('longitude', 'latitude')]
occs_vals <- data.frame(raster::extract(env_values, occs_xy, cellnumbers = TRUE))
# Removing occurrence records with NA environmental values
sp.occs.thinned <- sp.occs.thinned[!(rowSums(is.na(occs_vals)) >= 1), ]
# also removing variable value rows with NA environmental values
occs_vals <- na.omit(occs_vals)
# adding columns for env variable values for each occurrence record
sp.occs.thinned.vals <- cbind(sp.occs.thinned, occs_vals)
# Reducing the observations to one per cell
sp.occs.thinned.vals <- sp.occs.thinned.vals[!duplicated(sp.occs.thinned.vals[, 'cells']), ] %>%
dplyr::select(-cells)
n_inc_obs = nrow(sp.occs.thinned.vals)
if (debug == TRUE) {print(paste("n_inc_obs: ", n_inc_obs, sep = ""))}
# Dropping species with less than the minimum number of observations
# for those, no model is created just a file with the name of the species and the number of observations
if (n_inc_obs <= min_nr_occ){
if (debug == TRUE) {print("Not enough points. Modelling stopped.")}
dropped_species <- as.data.frame(t(c(species, n_obs_total, n_inc_obs)))
colnames(dropped_species) <- c("Species", "n_inc_obs", "n_inc_obs")
if (export == TRUE) {write_csv(dropped_species, paste("./../3_generated_data/res_dropped_species/", species, "_dropped.csv", sep = ""))}
next
}
# Selection of the background extent
# For species with few points "points buffers" and for species with a large number of points "minimum convex polygon"
# this difference is due to the computationally intensive task of selecting "points buffers" for large species
if (n_inc_obs <= bg_Sel_threshold) {
bg_Sel = "point buffers"
if (debug == TRUE) {print(paste("The number of observations is <=", bg_Sel_threshold, "using 'POINT BUFFER"))}
} else {
bg_Sel = "minimum convex polygon"
if (debug == TRUE) {print(paste("The number of observations is >", bg_Sel_threshold, "using 'MCP"))}
}
# Generate background extent
bgExt <- wallace::penvs_bgExtent(
occs = sp.occs.thinned.vals,
bgSel = bg_Sel,
bgBuf = bgBuf_radius_degrees)
# Mask environmental data to provided extent
bgMask <- wallace::penvs_bgMask(
occs = sp.occs.thinned.vals,
envs = envs,
bgExt = bgExt)
# Plotting the models geographically, without needing to run the models again
if (p_lot_unplotted == TRUE) {
if (file.exists(paste("./../3_generated_data/res_saved_models/", species, "_models.rds", sep = ""))) {
if (file.exists(paste("./../3_generated_data/res_SDM_plots/", species, "_global.png", sep = ""))) {next} else {
if (debug == TRUE) {print(paste("Generating plot for unplotted species:", species))}
models <- readRDS(paste("./../generated_data/res_saved_models/", species, "_models.rds", sep = ""))
results_ordered <- models@results[order(models@results$or.mtp.avg, -models@results$auc.val.avg),] %>%
mutate(env_breadth = NA) %>%
mutate(Species = species) %>%
mutate(n_obs_total = n_obs_total) %>%
mutate(n_inc_obs = n_inc_obs) %>%
dplyr::select(Species, env_breadth, n_inc_obs, everything())
# Exporting the best model as a .rds file
best_modelOR <- as.integer(rownames(results_ordered[1,]))
m <- models@models[[best_modelOR]]
env_breadth <- read_csv(list.files(path="./../3_generated_data/res_maxent_result_tables/", pattern= paste(species, "_maxent_results.csv", sep = ""), full.names=TRUE)) %>%
filter(Species == species) %>%
.$env_breadth
predSel <- wallace::predictMaxnet(m, bgMask,
type = "cloglog",
clamp = TRUE)
grDevices::png(filename = paste("./../tmp/res_SDM_plots/", species, "_local.png", sep = ""),
width = 4, height = 4, units = 'in', res = 1200)
plot(predSel, main = paste(species, "\nenv.breadth = ", round(env_breadth[1], 3), sep = ""),
sub = paste("nobs: ", n_inc_obs,
"; or.mtp.avg: ", round(results_ordered$or.mtp.avg[1], digits = 2),
"\nauc.val.avg: ", round(results_ordered$auc.val.avg[1], digits = 2),
"; or.10p.avg: ", round(results_ordered$or.10p.avg[1], digits = 2),
sep = ""))
dev.off()
predSel <- wallace::predictMaxnet(m, envs,
type = "cloglog",
clamp = TRUE)
grDevices::png(filename = paste("./../tmp/res_SDM_plots/", species, "_global.png", sep = ""),
width = 4, height = 4, units = 'in', res = 1200)
plot(predSel, main = paste(species, "\nenv.breadth = ", round(env_breadth[1], 3), sep = ""),
sub = paste("nobs: ", n_inc_obs,
"; or.mtp.avg: ", round(results_ordered$or.mtp.avg[1], digits = 2),
"\nauc.val.avg: ", round(results_ordered$auc.val.avg[1], digits = 2),
"; or.10p.avg: ", round(results_ordered$or.10p.avg[1], digits = 2),
sep = ""))
dev.off()
next
}
}
}
# Sample background points from the provided area
AvPoints <- raster::ncell(bgMask) - raster::freq(bgMask, value = NA)[[1]]
if (AvPoints >= 10000) {numberPoints <- 10000} else {numberPoints <- AvPoints}
bgSample <- wallace::penvs_bgSample(
occs = sp.occs.thinned.vals,
bgMask =  bgMask,
bgPtsNum = numberPoints)
# Extract values of environmental layers for each background point
bgEnvsVals <- as.data.frame(raster::extract(bgMask,  bgSample))
##Add extracted values to background points table
bgEnvsVals <- cbind(occID = NA, Species = paste0("bg_", species), bgSample, bgEnvsVals)
### Partition occurrence data
#Partition occurrences and background points for model training and
#validation using “hierarchical checkerboard”, a spatial partition method
#with an aggregation factor of 2.
# R code to get partitioned data
groups <- wallace::part_partitionOccs(
occs = sp.occs.thinned.vals ,
bg =  bgSample,
method = "cb2",
bgMask = bgMask,
aggFact = 2)
#  Generating a species distribution model using the maxnet algorithm as
#  implemented in ENMeval V2.0 (with clamping = FALSE). For tuning using L
#  feature classes and regularization multipliers in the 1, 2 range
#  increasing by 1. Not using any categorical predictor variables.
# Run maxent model for the selected species
models <- my_model_maxent(
occs = sp.occs.thinned.vals,
bg = bgEnvsVals,
user.grp = groups,
bgMsk = bgMask,
rms = c(1, 4),
rmsStep =  0.5,
fcs = c('L','LQ'),
clampSel = TRUE,
algMaxent = "maxnet",
parallel = FALSE,
numCores = 1)
if (export == TRUE) {saveRDS(models, file = paste("./../3_generated_data/res_saved_models/", species, "_models.rds", sep = ""))}
# Select best model and obtain raster prediction
results_ordered <- models@results[order(models@results$or.mtp.avg, -models@results$auc.val.avg),] %>%
mutate(env_breadth = NA) %>%
mutate(Species = species) %>%
mutate(n_obs_total = n_obs_total) %>%
mutate(n_inc_obs = n_inc_obs) %>%
dplyr::select(Species, env_breadth, n_inc_obs, everything())
# Exporting the best model as a .rds file
best_modelOR <- as.integer(rownames(results_ordered[1,]))
m <- models@models[[best_modelOR]]
# Adding the enironmental breadth of the best model to the results table
results_ordered$env_breadth[1] <- as.numeric(env.breadth.cloglog(model = m, env = env_values))
if (debug == TRUE) {
print(paste("------------------------------ Niche breadth of", species, ":", results_ordered$env_breadth[1]))
}
if (export == TRUE) {
write_csv(results_ordered %>% mutate(Species = species), paste("./../3_generated_data/res_maxent_result_tables/", species, "_maxent_results.csv", sep = ""))
}
if (p_lot == TRUE) {
predSel <- predictMaxnet(m, bgMask,
type = "cloglog",
clamp = TRUE)
grDevices::png(filename = paste("./../temp/res_SDM_plots/", species, "_local.png", sep = ""),
width = 4, height = 4, units = 'in', res = 1200)
plot(predSel, main = paste(species, "\nenv.breadth = ", round(results_ordered$env_breadth[1], 3), sep = ""),
sub = paste("nobs: ", n_inc_obs,
"; or.mtp.avg: ", round(results_ordered$or.mtp.avg[1], digits = 2),
"\nauc.val.avg: ", round(results_ordered$auc.val.avg[1], digits = 2),
"; or.10p.avg: ", round(results_ordered$or.10p.avg[1], digits = 2),
sep = ""))
dev.off()
predSel <- predictMaxnet(m, envs,
type = "cloglog",
clamp = TRUE)
grDevices::png(filename = paste("./../temp/res_SDM_plots/", species, "_global.png", sep = ""),
width = 4, height = 4, units = 'in', res = 1200)
plot(predSel, main = paste(species, "\nenv.breadth = ", round(results_ordered$env_breadth[1], 3), sep = ""),
sub = paste("nobs: ", n_inc_obs,
"; or.mtp.avg: ", round(results_ordered$or.mtp.avg[1], digits = 2),
"\nauc.val.avg: ", round(results_ordered$auc.val.avg[1], digits = 2),
"; or.10p.avg: ", round(results_ordered$or.10p.avg[1], digits = 2),
sep = ""))
dev.off()
}
}
}
run.maxnet(occurrences_df = ds,
species_list = "Campanula_thyrsoides",
env_values = envs)
MESS_trees <- list.files(path = "/Volumes/1TB_SSD/res_MESS_perHemisphere_trees",
pattern = "*_MESS_perHemisphere.csv", full.names = TRUE) %>%
map_df(~fread(., nrows = 1)) %>%
mutate(growthform = "tree")
library(tidyverse)
library(sjPlot)
library(sjmisc)
library(sjlabelled)
MESS_trees <- list.files(path = "/Volumes/1TB_SSD/res_MESS_perHemisphere_trees",
pattern = "*_MESS_perHemisphere.csv", full.names = TRUE) %>%
map_df(~fread(., nrows = 1)) %>%
mutate(growthform = "tree")
??fread
MESS_trees <- list.files(path = "/Volumes/1TB_SSD/res_MESS_perHemisphere_trees",
pattern = "*_MESS_perHemisphere.csv", full.names = TRUE) %>%
map_df(~data.table::fread(., nrows = 1)) %>%
mutate(growthform = "tree")
MESS_perHemisphere_trees <- list.files(path = "/Volumes/1TB_SSD/res_MESS_perHemisphere_trees",
pattern = "*_MESS_perHemisphere.csv", full.names = TRUE) %>%
map_df(~data.table::fread(., nrows = 1)) %>%
mutate(growthform = "tree")
View(MESS_perHemisphere_trees)
dt <- read_csv("./3_generated_data/niche_data_final_summarized_v4.csv")
setwd("/Users/marco/GitHub/environmental_breadth_final/"); getwd()
dt <- read_csv("./3_generated_data/niche_data_final_summarized_v4.csv")
View(dt)
MESS_perHemisphere_trees <- list.files(path = "/Volumes/1TB_SSD/res_MESS_perHemisphere_trees",
pattern = "*_MESS_perHemisphere.csv", full.names = TRUE) %>%
map_df(~data.table::fread(., nrows = 1)) %>%
mutate(growthform = "tree") %>%
rename(Species = species)
dt <- read_csv("./3_generated_data/niche_data_final_summarized_v4.csv") %>%
inner_join(MESS_perHemisphere, by = "Species")
dt <- read_csv("./3_generated_data/niche_data_final_summarized_v4.csv") %>%
inner_join(MESS_perHemisphere_trees, by = "Species")
dt <- read_csv("./3_generated_data/niche_data_final_summarized_v4.csv")
dt <- read_csv("./3_generated_data/niche_data_final_summarized_v4.csv") %>%
filter(growthform == "tree")
dt <- read_csv("./3_generated_data/niche_data_final_summarized_v4.csv") %>%
filter(growthform == "tree") %>%
inner_join(MESS_perHemisphere_trees, by = "Species")
View(dt)
# For the southern hemisphere
dt <- read_csv("./3_generated_data/niche_data_final_summarized_v4.csv") %>%
filter(growthform == "tree") %>%
inner_join(MESS_perHemisphere_trees, by = "Species") %>%
mutate(e_breadth = (env_breadth*value_s)^(1/4))
# For the southern hemisphere
dt <- read_csv("./3_generated_data/niche_data_final_summarized_v4.csv") %>%
filter(growthform == "tree") %>%
inner_join(MESS_perHemisphere_trees, by = "Species") %>%
mutate(e_breadth = (env_breadth*value_S)^(1/4))
library(leaflet)
library(DT)
library(scales)
library(tidyverse)
library(sf)
library(htmltools)
setwd("/Users/marco/GitHub/graslandvielfalt/R_files")
source("./config_plot_map.R")
#municipalities <- st_read("./gadm41_CHE.gpkg", layer = "ADM_ADM_3")
#plots <- read_csv("./2023-joinedPlotSelection_v2.csv") %>%
#  get_municipality(., municipalities, what = c("NAME_1", "NAME_3")) %>%
#  rename(canton = NAME_1,
#         municipality = NAME_3) %>%
#  mutate(priority = gsub("A", "", priority)) %>%
#  arrange(priority, canton, municipality, elevation) %>%
#  group_by(municipality) %>%
#  mutate(ID = paste0(priority, "-",
#                     toupper(substr(canton, 1, 2)), "-",
#                     toupper(substr(municipality, 1, 2)), "-",
#                     row_number())) %>%
#  ungroup() %>%
#  select(ID, elevation, canton, municipality, mgroup, LU1980, LU2000, LU2020, LNF_Code, everything()) %>%
#  arrange(priority, elevation)
#write_csv(plots, "./2023-joinedPlotSelection_v3.csv")
plots <- read_csv("./2023-joinedPlotSelection_v3.csv")
donePlots <- read_csv("./2023-donePlots.csv") %>%
filter(!is.na(Done))
#be <- rgdal::readOGR("/Users/marco/kDocuments_Marco/PhD/server/1_original_data/shapefiles/be_bewirtschaftungseinheit_view.shp")
#poly <- be %>%
#  get_polygons(plots = plots, shapefile = ., radius_m = 500)
#
#writeOGR(poly, dsn = "./2023-plots-with-be-poly.geojson",
#         layer = ogrListLayers("/Users/marco/kDocuments_Marco/PhD/server/1_original_data/shapefiles/be_bewirtschaftungseinheit_view.shp")[1],
#         driver = "GeoJSON")
poly <- rgdal::readOGR("./2023-plots-with-be-poly.geojson")
########################################################################################################################################
### Create plot table #################################################################################################################
########################################################################################################################################
(t <- DT::datatable(plots,
class = "display nowrap",
escape = F,
rownames = FALSE))
#htmltools::save_html(t, file="2023-plot-table.html")
########################################################################################################################################
### Create a leaflet map with the Swiss Topographic Map as a basemap ###################################################################
########################################################################################################################################
# Define a color palette with distinct colors
pal <- colorFactor(
palette = c("red", "orange", "yellow", "green", "blue", "purple", "magenta"),
domain = plots$priority
)
# Create a leaflet map with the Swiss Topographic Map as a basemap
(m <- leaflet(plots) %>%
addTiles(urlTemplate = "https://wmts20.geo.admin.ch/1.0.0/ch.swisstopo.pixelkarte-farbe/default/current/3857/{z}/{x}/{y}.jpeg",
attribution = '&copy; <a href="https://www.geo.admin.ch/de/about-swiss-geoportal/impressum.html#copyright">swisstopo</a>') %>%
# Add a button for each category in the priority variable
addLayersControl(
overlayGroups = c(unique(plots$priority), "Done Plots", "Bewirtschaftungseinheiten"),
options = layersControlOptions(collapsed = TRUE)
) %>%
addCircleMarkers(data = plots,
lat = ~Latitude, lng = ~Longitude,
popup = ~paste(ID, round(elevation, 0), sep = " - "),
radius = 8, stroke = FALSE, fillOpacity = 1, color = ~pal(priority),
group = ~priority) %>%
addLegend(pal = pal, values = plots$priority,
position = "bottomright", title = "Value") %>%
addScaleBar(position = "bottomleft") %>%
setView(lng = 9, lat = 46.4, zoom = 8) %>%
addPolygons(data = poly,
fill = FALSE,
color = "darkorange",
opacity = 0.9,
group = "Bewirtschaftungseinheiten") %>%
addAwesomeMarkers(data = donePlots,
lat = ~Latitude, lng = ~Longitude,
icon = ~awesomeIcons(
icon = "leaf",
markerColor = "green",
iconColor = "white",
library = "fa"
),
labelOptions = labelOptions(noHide = TRUE, textOnly = TRUE),
label = lapply(donePlots$ID, HTML),
clusterOptions = markerClusterOptions(removeOutsideVisibleBounds = FALSE),
group = "Done Plots") %>%
hideGroup("Bewirtschaftungseinheiten") #"MP3", "MP4", "MP5", "MP6", "MP7", "P2", "P3"
)
(m <- leaflet(plots) %>%
addTiles(urlTemplate = "https://wmts20.geo.admin.ch/1.0.0/ch.swisstopo.pixelkarte-farbe/default/current/3857/{z}/{x}/{y}.jpeg",
attribution = '&copy; <a href="https://www.geo.admin.ch/de/about-swiss-geoportal/impressum.html#copyright">swisstopo</a>',
group = "Swiss Topographic Map") %>%
addTiles(urlTemplate = "https://wmts20.geo.admin.ch/1.0.0/ch.swisstopo.swissimage/default/current/3857/{z}/{x}/{y}.jpeg",
attribution = '&copy; <a href="https://www.geo.admin.ch/de/about-swiss-geoportal/impressum.html#copyright">swisstopo</a>',
group = "Satellite View") %>%
addLayersControl(
baseGroups = c("Swiss Topographic Map", "Satellite View"),
overlayGroups = c(unique(plots$priority), "Done Plots", "Bewirtschaftungseinheiten"),
options = layersControlOptions(collapsed = TRUE)
) %>%
addCircleMarkers(data = plots,
lat = ~Latitude, lng = ~Longitude,
popup = ~paste(ID, round(elevation, 0), sep = " - "),
radius = 8, stroke = FALSE, fillOpacity = 1, color = ~pal(priority),
group = ~priority) %>%
addLegend(pal = pal, values = plots$priority,
position = "bottomright", title = "Value") %>%
addScaleBar(position = "bottomleft") %>%
setView(lng = 9, lat = 46.4, zoom = 8) %>%
addPolygons(data = poly,
fill = FALSE,
color = "darkorange",
opacity = 0.9,
group = "Bewirtschaftungseinheiten") %>%
addAwesomeMarkers(data = donePlots,
lat = ~Latitude, lng = ~Longitude,
icon = ~awesomeIcons(
icon = "leaf",
markerColor = "green",
iconColor = "white",
library = "fa"
),
labelOptions = labelOptions(noHide = TRUE, textOnly = TRUE),
label = lapply(donePlots$ID, HTML),
clusterOptions = markerClusterOptions(removeOutsideVisibleBounds = FALSE),
group = "Done Plots") %>%
hideGroup(c("Bewirtschaftungseinheiten", "MP5", "MP6", "MP7", "P3"))
)
htmlwidgets::saveWidget(m, file=paste("./2023-plot-map.html", sep = ""))
###### CREATING THE MUNICIPALITY MAP ############################################
municipalities <- read_csv("./2023-joinedPlotSelection_v2.csv") %>%
get_municipality(., municipalities, what = c("NAME_1", "NAME_3")) %>%
rename(canton = NAME_1,
municipality = NAME_3) %>%
select(canton, municipality)
library(leaflet)
library(DT)
library(scales)
library(tidyverse)
library(sf)
library(htmltools)
setwd("/Users/marco/GitHub/graslandvielfalt/R_files")
source("./config_plot_map.R")
#municipalities <- st_read("./gadm41_CHE.gpkg", layer = "ADM_ADM_3")
#plots <- read_csv("./2023-joinedPlotSelection_v2.csv") %>%
#  get_municipality(., municipalities, what = c("NAME_1", "NAME_3")) %>%
#  rename(canton = NAME_1,
#         municipality = NAME_3) %>%
#  mutate(priority = gsub("A", "", priority)) %>%
#  arrange(priority, canton, municipality, elevation) %>%
#  group_by(municipality) %>%
#  mutate(ID = paste0(priority, "-",
#                     toupper(substr(canton, 1, 2)), "-",
#                     toupper(substr(municipality, 1, 2)), "-",
#                     row_number())) %>%
#  ungroup() %>%
#  select(ID, elevation, canton, municipality, mgroup, LU1980, LU2000, LU2020, LNF_Code, everything()) %>%
#  arrange(priority, elevation)
#write_csv(plots, "./2023-joinedPlotSelection_v3.csv")
plots <- read_csv("./2023-joinedPlotSelection_v3.csv")
donePlots <- read_csv("./2023-donePlots.csv") %>%
filter(Done == 1)
#be <- rgdal::readOGR("/Users/marco/kDocuments_Marco/PhD/server/1_original_data/shapefiles/be_bewirtschaftungseinheit_view.shp")
#poly <- be %>%
#  get_polygons(plots = plots, shapefile = ., radius_m = 500)
#
#writeOGR(poly, dsn = "./2023-plots-with-be-poly.geojson",
#         layer = ogrListLayers("/Users/marco/kDocuments_Marco/PhD/server/1_original_data/shapefiles/be_bewirtschaftungseinheit_view.shp")[1],
#         driver = "GeoJSON")
poly <- rgdal::readOGR("./2023-plots-with-be-poly.geojson")
########################################################################################################################################
### Create plot table #################################################################################################################
########################################################################################################################################
(t <- DT::datatable(plots,
class = "display nowrap",
escape = F,
rownames = FALSE))
#htmltools::save_html(t, file="2023-plot-table.html")
########################################################################################################################################
### Create a leaflet map with the Swiss Topographic Map as a basemap ###################################################################
########################################################################################################################################
# Define a color palette with distinct colors
pal <- colorFactor(
palette = c("red", "orange", "yellow", "green", "blue", "purple", "magenta"),
domain = plots$priority
)
# Create a leaflet map with the Swiss Topographic Map as a basemap
(m <- leaflet(plots) %>%
addTiles(urlTemplate = "https://wmts20.geo.admin.ch/1.0.0/ch.swisstopo.pixelkarte-farbe/default/current/3857/{z}/{x}/{y}.jpeg",
attribution = '&copy; <a href="https://www.geo.admin.ch/de/about-swiss-geoportal/impressum.html#copyright">swisstopo</a>') %>%
# Add a button for each category in the priority variable
addLayersControl(
overlayGroups = c(unique(plots$priority), "Done Plots", "Bewirtschaftungseinheiten"),
options = layersControlOptions(collapsed = TRUE)
) %>%
addCircleMarkers(data = plots,
lat = ~Latitude, lng = ~Longitude,
popup = ~paste(ID, round(elevation, 0), sep = " - "),
radius = 8, stroke = FALSE, fillOpacity = 1, color = ~pal(priority),
group = ~priority) %>%
addLegend(pal = pal, values = plots$priority,
position = "bottomright", title = "Value") %>%
addScaleBar(position = "bottomleft") %>%
setView(lng = 9, lat = 46.4, zoom = 8) %>%
addPolygons(data = poly,
fill = FALSE,
color = "darkorange",
opacity = 0.9,
group = "Bewirtschaftungseinheiten") %>%
addAwesomeMarkers(data = donePlots,
lat = ~Latitude, lng = ~Longitude,
icon = ~awesomeIcons(
icon = "leaf",
markerColor = "green",
iconColor = "white",
library = "fa"
),
labelOptions = labelOptions(noHide = TRUE, textOnly = TRUE),
label = lapply(donePlots$ID, HTML),
clusterOptions = markerClusterOptions(removeOutsideVisibleBounds = FALSE),
group = "Done Plots") %>%
hideGroup("Bewirtschaftungseinheiten") #"MP3", "MP4", "MP5", "MP6", "MP7", "P2", "P3"
)
(m <- leaflet(plots) %>%
addTiles(urlTemplate = "https://wmts20.geo.admin.ch/1.0.0/ch.swisstopo.pixelkarte-farbe/default/current/3857/{z}/{x}/{y}.jpeg",
attribution = '&copy; <a href="https://www.geo.admin.ch/de/about-swiss-geoportal/impressum.html#copyright">swisstopo</a>',
group = "Swiss Topographic Map") %>%
addTiles(urlTemplate = "https://wmts20.geo.admin.ch/1.0.0/ch.swisstopo.swissimage/default/current/3857/{z}/{x}/{y}.jpeg",
attribution = '&copy; <a href="https://www.geo.admin.ch/de/about-swiss-geoportal/impressum.html#copyright">swisstopo</a>',
group = "Satellite View") %>%
addLayersControl(
baseGroups = c("Swiss Topographic Map", "Satellite View"),
overlayGroups = c(unique(plots$priority), "Done Plots", "Bewirtschaftungseinheiten"),
options = layersControlOptions(collapsed = TRUE)
) %>%
addCircleMarkers(data = plots,
lat = ~Latitude, lng = ~Longitude,
popup = ~paste(ID, round(elevation, 0), sep = " - "),
radius = 8, stroke = FALSE, fillOpacity = 1, color = ~pal(priority),
group = ~priority) %>%
addLegend(pal = pal, values = plots$priority,
position = "bottomright", title = "Value") %>%
addScaleBar(position = "bottomleft") %>%
setView(lng = 9, lat = 46.4, zoom = 8) %>%
addPolygons(data = poly,
fill = FALSE,
color = "darkorange",
opacity = 0.9,
group = "Bewirtschaftungseinheiten") %>%
addAwesomeMarkers(data = donePlots,
lat = ~Latitude, lng = ~Longitude,
icon = ~awesomeIcons(
icon = "leaf",
markerColor = "green",
iconColor = "white",
library = "fa"
),
labelOptions = labelOptions(noHide = TRUE, textOnly = TRUE),
label = lapply(donePlots$ID, HTML),
clusterOptions = markerClusterOptions(removeOutsideVisibleBounds = FALSE),
group = "Done Plots") %>%
hideGroup(c("Bewirtschaftungseinheiten", "MP5", "MP6", "MP7", "P3"))
)
htmlwidgets::saveWidget(m, file=paste("./2023-plot-map.html", sep = ""))
###### CREATING THE MUNICIPALITY MAP ############################################
#municipalities <- read_csv("./2023-joinedPlotSelection_v2.csv") %>%
#  get_municipality(., municipalities, what = c("NAME_1", "NAME_3")) %>%
#  rename(canton = NAME_1,
#         municipality = NAME_3) %>%
#  select(canton, municipality)
